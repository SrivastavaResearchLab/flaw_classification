"""
Python script to generate multiple types of flaw conditions in a 3D pipe including
(1) No flaw
(2) One embedded elliptical crack
(3) Two embedded elliptical cracks
(4) Wall loss corrosion
(5) Wall loss corrosion with one embedded elliptical crack

In additional to the fives types of flaw condition, these parameters are associated with the flaws
(a) long axis of crack
(b) short axis of crack (not a variable)
(c) depth of crack
(d) orientation of crack
(e) width of wall loss
(f) height of wall loss
(g) relative horizontal distance between two cracks (cc)
(h) relative horizontal distance between wall loss and crack (wc)

Additional notes:
	If wall loss is present, it will be placed in the middle of the geometry, right above the probe
	If two cracks are considered, one of them will be placed in the middle of the geometry, right above the probe

There are in total three output files generated by this python script
1 - Combined_flaw_3D.csv contains simulation data in a time-amplitude form
2 - Combined_flaw_3D_info.csv contains all the crack info that correspond to the above simulation
3 - Combined_flaw_failed_simulation.txt contains information about all the failed simulations

Written by Sijun Niu, April 15th 2021
"""

############################################################################################################
# -*- coding: mbcs -*-

"""Import modules"""
from part import *
from material import *
from section import *
from assembly import *
from step import *
from interaction import *
from load import *
from mesh import *
from optimization import *
from job import *
from sketch import *
from visualization import *
from connectorBehavior import *
from odbAccess import *
import sys
import os
import random
import math
import xlsxwriter
import time

"""This command uses findAt functions to locate objects such as faces and cells, instead of getSequencyFromMask"""
session.journalOptions.setValues(replayGeometry=COORDINATE, recoverGeometry=COORDINATE)

"""Number of simulation"""
num_of_simulation = 1

"""Flaw type condition (see above for meaning of each number)"""
flaw_type = 5

"""Activate the corresponding properties to be used in the simulation according to flaw type"""
long_axis_1 = False
depth_1 = False
angle_1 = False
loss_height = False
loss_width = False
long_axis_2 = False
depth_2 = False
angle_2 = False
horizontal_cc = False
horizontal_wc = False

'''
if flaw_type == 2:
	long_axis_1 = True
	depth_1 = True
	angle_1 = True
elif flaw_type == 3:
	long_axis_1 = True
	depth_1 = True
	angle_1 = True
	long_axis_2 = True
	depth_2 = True
	angle_2 = True
	horizontal_cc = True
elif flaw_type == 4:
	loss_height = True
	loss_width = True
elif flaw_type == 5:
	loss_height = True
	loss_width = True
	long_axis_2 = True
	depth_2 = True
	angle_2 = True
	horizontal_wc = True'''

"""Remove the old files"""
# Set the flag to True if odb is not needed
remove_odb = True

try:
	os.remove('combined_flaw_3D/Combined_flaw_3D.xlsx')
except WindowsError:
	pass
try:
	os.remove('combined_flaw_3D/Combined_flaw_3D_info.xlsx')
except WindowsError:
	pass

"""Create workbooks to store simulation data"""
wb1 = xlsxwriter.Workbook('combined_flaw_3D/Combined_flaw_3D.xlsx')
wb2 = xlsxwriter.Workbook('combined_flaw_3D/Combined_flaw_3D_info.xlsx')
sheet1 = wb1.add_worksheet()
sheet2 = wb2.add_worksheet()

"""Set the generic parameters of the simulation, irrelevant to the flaw type"""

# Partition size near the wall loss
part_x_wall = 0.002
part_y_wall = 0.001

# Partition size near the crack
part_x_crack = 0.003
part_y_crack = 0.003

# Coarse mesh for regions far from the flaws
mesh_size_coarse = 0.002

# General mesh size for flaw regions
mesh_size_general = 0.0001

# Fine mesh near the elliptical crack
mesh_size_fine = 0.0001

# Total time and user-fixed time increment
total_time = 8e-06
time_increment = 2e-09
sampling_number = total_time / time_increment

# Material parameters of the plate [SI unit]
young_modulus = 180000000000.0
poisson_ratio = 0.312
mat_density = 7300

# List to store failed simulation info
failed_mesh = []
failed_earlystop = []

# Default geometric properties for crack and wall loss
# Variables that don't change
default_short_axis_1 = 0.0003
default_short_axis_2 = 0.0003

# Variables that might change
default_long_axis_1 = 0.002
default_depth_1 = 0.011
default_angle_1 = math.pi/6.0
default_long_axis_2 = 0.002
default_depth_2 = 0.013
default_angle_2 = math.pi/4.0
default_loss_height = 0.002
default_loss_width = 0.012
default_horizontal_wc = 0.002
default_horizontal_cc = 0.003

# Range for the geometric properties if the flag is set to true
long_axis_1_min = 0.0005
long_axis_1_max = 0.0025
depth_1_min = 0.007
depth_1_max = 0.015
angle_1_min = 0.0
angle_1_max = math.pi
loss_height_min = 0.001
loss_height_max = 0.006
loss_width_min = 0.012
loss_width_max = 0.025
horizontal_wc_min = -0.005
horizontal_wc_max = 0.005
horizontal_cc_min = 0.0
horizontal_cc_max = 0.005
long_axis_2_min = 0.0005
long_axis_2_max = 0.0025
depth_2_min = 0.007
depth_2_max = 0.015
angle_2_min = 0.0
angle_2_max = math.pi

# Set default crack information if not otherwise specified in the loop
if long_axis_1:
	long_axis_1s = [random.uniform(long_axis_1_min, long_axis_1_max) for i in range(num_of_simulation)]
else:
	long_axis_1s = [default_long_axis_1 for i in range(num_of_simulation)]

if depth_1:
	depth_1s = [random.uniform(depth_1_min, depth_1_max) for i in range(num_of_simulation)]
else:
	depth_1s = [default_depth_1 for i in range(num_of_simulation)]

if angle_1:
	angle_1s = [random.uniform(angle_1_min, angle_1_max) for i in range(num_of_simulation)]
else:
	angle_1s = [default_angle_1 for i in range(num_of_simulation)]

if loss_width:
	loss_widths = [random.uniform(loss_width_min, loss_width_max) for i in range(num_of_simulation)]
else:
	loss_widths = [default_loss_width for i in range(num_of_simulation)]

if loss_height:
	loss_heights = [random.uniform(loss_height_min, loss_height_max) for i in range(num_of_simulation)]
else:
	loss_heights = [default_loss_height for i in range(num_of_simulation)]

if long_axis_2:
	long_axis_2s = [random.uniform(long_axis_2_min, long_axis_2_max) for i in range(num_of_simulation)]
else:
	long_axis_2s = [default_long_axis_2 for i in range(num_of_simulation)]

if depth_2:
	depth_2s = [random.uniform(depth_2_min, depth_2_max) for i in range(num_of_simulation)]
else:
	depth_2s = [default_depth_2 for i in range(num_of_simulation)]

if angle_2:
	angle_2s = [random.uniform(angle_2_min, angle_2_max) for i in range(num_of_simulation)]
else:
	angle_2s = [default_angle_2 for i in range(num_of_simulation)]

if horizontal_cc:
	horizontal_ccs = [random.uniform(horizontal_cc_min + part_x_crack * (abs(depth_2s[i] - depth_1s[i]) < part_y_crack),
					horizontal_cc_max) * (random.randint(0,1) * 2 - 1) for i in range(num_of_simulation)]
else:
	horizontal_ccs = [default_horizontal_cc for i in range(num_of_simulation)]

if horizontal_wc:
	horizontal_wcs = [random.uniform(horizontal_wc_min, horizontal_wc_max) for i in range(num_of_simulation)]
	depth_2s = [random.uniform(0.015 - loss_heights[i], 0.015 - loss_heights[i]) for i in range(num_of_simulation)]
else:
	horizontal_wcs = [default_horizontal_wc for i in range(num_of_simulation)]

"""Initiate the while loop"""
current_index = 1
while current_index <= num_of_simulation:

	"""Variables that don't change at all"""
	current_short_axis_1 = default_short_axis_1
	current_short_axis_2 = default_short_axis_2

	"""Variable that might change"""
	current_long_axis_1 = long_axis_1s[current_index - 1]
	current_depth_1 = depth_1s[current_index - 1]
	current_angle_1 = angle_1s[current_index - 1]
	current_long_axis_2 = long_axis_2s[current_index - 1]
	current_depth_2 = depth_2s[current_index - 1]
	current_angle_2 = angle_2s[current_index - 1]
	current_loss_width = loss_widths[current_index - 1]
	current_loss_height = loss_heights[current_index - 1]
	current_horizontal_wc = horizontal_wcs[current_index - 1]
	current_horizontal_cc = horizontal_ccs[current_index - 1]

	## Create 3D part
	mdb.models['Model-1'].ConstrainedSketch(name='__profile__', sheetSize=0.5)
	mdb.models['Model-1'].sketches['__profile__'].rectangle(point1=(0.0, 0.0), point2=(0.05, 0.025))
	mdb.models['Model-1'].Part(dimensionality=THREE_D, name='pipe', type=DEFORMABLE_BODY)
	mdb.models['Model-1'].parts['pipe'].BaseSolidExtrude(depth=0.019, sketch=
	mdb.models['Model-1'].sketches['__profile__'])
	del mdb.models['Model-1'].sketches['__profile__']

	## Define axes globally
	datum_x = mdb.models['Model-1'].parts['pipe'].DatumAxisByPrincipalAxis(principalAxis=XAXIS)
	datum_y = mdb.models['Model-1'].parts['pipe'].DatumAxisByPrincipalAxis(principalAxis=YAXIS)
	datum_z = mdb.models['Model-1'].parts['pipe'].DatumAxisByPrincipalAxis(principalAxis=ZAXIS)

	if flaw_type < 4:
		"""Create at least one elliptical crack"""
		# Mesh number around the elliptical crack 1
		approx_circ_1 = 2 * math.pi * math.sqrt((current_long_axis_1 ** 2 + current_short_axis_1 ** 2) / 2)
		mesh_number_1 = int(approx_circ_1 / mesh_size_fine)

		# Mesh number around the elliptical crack 2
		approx_circ_2 = 2 * math.pi * math.sqrt((current_long_axis_2 ** 2 + current_short_axis_2 ** 2) / 2)
		mesh_number_2 = int(approx_circ_2 / mesh_size_fine)

		## Create the first crack
		# Revolve cut of the center cell
		mdb.models['Model-1'].ConstrainedSketch(gridSpacing=0.001, name='__profile__',sheetSize=0.044, transform=
			mdb.models['Model-1'].parts['pipe'].MakeSketchTransform(
			sketchPlane=mdb.models['Model-1'].parts['pipe'].faces.findAt((0.025,0.0,0.001), ),
			sketchPlaneSide=SIDE1,sketchUpEdge=mdb.models['Model-1'].parts['pipe'].edges.findAt((0.05,0.0,0.001), ),
			sketchOrientation=RIGHT, origin=(0.025, 0.0, 0.0095)))
		mdb.models['Model-1'].sketches['__profile__'].sketchOptions.setValues(decimalPlaces=3)
		mdb.models['Model-1'].parts['pipe'].projectReferencesOntoSketch(filter=
			COPLANAR_EDGES, sketch=mdb.models['Model-1'].sketches['__profile__'])
		mdb.models['Model-1'].sketches['__profile__'].ConstructionLine(point1=(0.0, 0.0095 - current_depth_1),
			point2=(-math.tan(current_angle_1), 0.0095 - current_depth_1 + 1))

		# Save the construction line
		const_line_1 = mdb.models['Model-1'].sketches['__profile__'].geometry.findAt(
			(math.tan(current_angle_1), 0.0095 - current_depth_1 - 1))

		mdb.models['Model-1'].sketches['__profile__'].EllipseByCenterPerimeter(
			axisPoint1=(-current_short_axis_1 * math.sin(current_angle_1),
			current_short_axis_1 * math.cos(current_angle_1) + 0.0095 - current_depth_1),
			axisPoint2=(current_long_axis_1 * math.cos(current_angle_1),
			current_long_axis_1 * math.sin(current_angle_1) + 0.0095 - current_depth_1), center=(0.0, 0.0095 - current_depth_1))
		mdb.models['Model-1'].sketches['__profile__'].breakCurve(
			curve1=mdb.models['Model-1'].sketches['__profile__'].geometry.findAt(
			(current_long_axis_1 * math.cos(current_angle_1),
			current_long_axis_1 * math.sin(current_angle_1) + 0.0095 - current_depth_1)),
			curve2=const_line_1, point1=(current_long_axis_1 * math.cos(current_angle_1),
			current_long_axis_1 * math.sin(current_angle_1) + 0.0095 - current_depth_1),
			point2=(0.0095 - current_depth_1 + 1, -math.tan(current_angle_1)))
		mdb.models['Model-1'].sketches['__profile__'].delete(objectList=(
			mdb.models['Model-1'].sketches['__profile__'].geometry.findAt((-current_long_axis_1 * math.cos(current_angle_1),
			-current_long_axis_1 * math.sin(current_angle_1) + 0.0095 - current_depth_1), ),))
		mdb.models['Model-1'].sketches['__profile__'].Line(
			point1=(-current_short_axis_1 * math.sin(current_angle_1),
			current_short_axis_1 * math.cos(current_angle_1) + 0.0095 - current_depth_1),
			point2=(current_short_axis_1 * math.sin(current_angle_1),
			-current_short_axis_1 * math.cos(current_angle_1) + 0.0095 - current_depth_1))
		mdb.models['Model-1'].sketches['__profile__'].sketchOptions.setValues(constructionGeometry=ON)
		mdb.models['Model-1'].sketches['__profile__'].assignCenterline(line=const_line_1)
		mdb.models['Model-1'].parts['pipe'].CutRevolve(angle=180.0,flipRevolveDirection=OFF, sketch=
			mdb.models['Model-1'].sketches['__profile__'],sketchOrientation=RIGHT,
			sketchPlane=mdb.models['Model-1'].parts['pipe'].faces.findAt((0.025, 0.0, 0.001), ),
			sketchPlaneSide=SIDE1, sketchUpEdge=mdb.models['Model-1'].parts['pipe'].edges.findAt((0.05, 0.0, 0.001),))
		del mdb.models['Model-1'].sketches['__profile__']

		# Create datum point based on the 1st crack location
		mdb.models['Model-1'].parts['pipe'].DatumPointByCoordinate(coords=(0.0, 0.0, 0.019 - current_depth_1))
		mdb.models['Model-1'].parts['pipe'].DatumPointByCoordinate(coords=(0.0, 0.0, 0.019 - current_depth_1 + part_y_crack))
		mdb.models['Model-1'].parts['pipe'].DatumPointByCoordinate(coords=(0.0, 0.0, 0.019 - current_depth_1 - part_y_crack))

		# Create the second crack
		if flaw_type == 3:
			mdb.models['Model-1'].ConstrainedSketch(gridSpacing=0.001, name='__profile__',sheetSize=0.044, transform=
				mdb.models['Model-1'].parts['pipe'].MakeSketchTransform(
				sketchPlane=mdb.models['Model-1'].parts['pipe'].faces.findAt((0.025,0.0,0.001), ),
				sketchPlaneSide=SIDE1,sketchUpEdge=mdb.models['Model-1'].parts['pipe'].edges.findAt((0.05,0.0,0.001), ),
				sketchOrientation=RIGHT, origin=(0.025, 0.0, 0.0095)))
			mdb.models['Model-1'].sketches['__profile__'].sketchOptions.setValues(decimalPlaces=3)
			mdb.models['Model-1'].parts['pipe'].projectReferencesOntoSketch(filter=
				COPLANAR_EDGES, sketch=mdb.models['Model-1'].sketches['__profile__'])
			mdb.models['Model-1'].sketches['__profile__'].ConstructionLine(point1=(current_horizontal_cc, 0.0095 - current_depth_2),
				point2=(-math.tan(current_angle_2) + current_horizontal_cc, 0.0095 - current_depth_2 + 1))
	
			# Save the construction line
			const_line_2 = mdb.models['Model-1'].sketches['__profile__'].geometry.findAt(
				(math.tan(current_angle_2) + current_horizontal_cc, 0.0095 - current_depth_2 - 1))

			mdb.models['Model-1'].sketches['__profile__'].EllipseByCenterPerimeter(
				axisPoint1=(-current_short_axis_2 * math.sin(current_angle_2) + current_horizontal_cc,
				current_short_axis_2 * math.cos(current_angle_2) + 0.0095 - current_depth_2),
				axisPoint2=(current_long_axis_2 * math.cos(current_angle_2) + current_horizontal_cc,
				current_long_axis_2 * math.sin(current_angle_2) + 0.0095 - current_depth_2), center=(
				current_horizontal_cc, 0.0095 - current_depth_2))
			mdb.models['Model-1'].sketches['__profile__'].breakCurve(
				curve1=mdb.models['Model-1'].sketches['__profile__'].geometry.findAt(
				(current_long_axis_2 * math.cos(current_angle_2) + current_horizontal_cc,
				current_long_axis_2 * math.sin(current_angle_2) + 0.0095 - current_depth_2)),
				curve2=const_line_2, point1=(current_long_axis_2 * math.cos(current_angle_2) + current_horizontal_cc,
				current_long_axis_2 * math.sin(current_angle_2) + 0.0095 - current_depth_2),
				point2=(0.0095 - current_depth_2 + 1 + current_horizontal_cc, -math.tan(current_angle_2)))
			mdb.models['Model-1'].sketches['__profile__'].delete(objectList=(
				mdb.models['Model-1'].sketches['__profile__'].geometry.findAt((
				-current_long_axis_2 * math.cos(current_angle_2) + current_horizontal_cc,
				-current_long_axis_2 * math.sin(current_angle_2) + 0.0095 - current_depth_2), ),))
			mdb.models['Model-1'].sketches['__profile__'].Line(
				point1=(-current_short_axis_2 * math.sin(current_angle_2) + current_horizontal_cc,
				current_short_axis_2 * math.cos(current_angle_2) + 0.0095 - current_depth_2),
				point2=(current_short_axis_2 * math.sin(current_angle_2) + current_horizontal_cc,
				-current_short_axis_2 * math.cos(current_angle_2) + 0.0095 - current_depth_2))
			mdb.models['Model-1'].sketches['__profile__'].sketchOptions.setValues(constructionGeometry=ON)
			mdb.models['Model-1'].sketches['__profile__'].assignCenterline(line=const_line_2)
			mdb.models['Model-1'].parts['pipe'].CutRevolve(angle=180.0,flipRevolveDirection=OFF, sketch=
				mdb.models['Model-1'].sketches['__profile__'],sketchOrientation=RIGHT,
				sketchPlane=mdb.models['Model-1'].parts['pipe'].faces.findAt((0.025, 0.0, 0.001), ),
				sketchPlaneSide=SIDE1, sketchUpEdge=mdb.models['Model-1'].parts['pipe'].edges.findAt((0.05, 0.0, 0.001),))
			del mdb.models['Model-1'].sketches['__profile__']

			# Create datum point based on the 1st crack location
			mdb.models['Model-1'].parts['pipe'].DatumPointByCoordinate(coords=(0.0, 0.0, 0.019 - current_depth_2))
			mdb.models['Model-1'].parts['pipe'].DatumPointByCoordinate(coords=(0.0, 0.0, 0.019 - current_depth_2 + part_y_crack))
			mdb.models['Model-1'].parts['pipe'].DatumPointByCoordinate(coords=(0.0, 0.0, 0.019 - current_depth_2 - part_y_crack))
			if current_horizontal_cc > 0:
				mdb.models['Model-1'].parts['pipe'].DatumPointByCoordinate(coords=(
					0.025 + current_horizontal_cc + part_x_crack, 0.0, 0.0))
			else:
				mdb.models['Model-1'].parts['pipe'].DatumPointByCoordinate(coords=(
					0.025 + current_horizontal_cc - part_x_crack, 0.0, 0.0))

	else:
		"""Create wall loss"""
		# Mesh number around the wall loss
		approx_length = math.pi * math.sqrt(((current_loss_width/2) ** 2 + current_loss_height ** 2)/2)
		mesh_number_1 = int(approx_length/mesh_size_fine)

		# Mesh number around the elliptical crack 2
		approx_circ_2 = 2 * math.pi * math.sqrt((current_long_axis_2 ** 2 + current_short_axis_2 ** 2) / 2)
		mesh_number_2 = int(approx_circ_2 / mesh_size_fine)

		# Revolve cut out a wall loss corrosion
		mdb.models['Model-1'].ConstrainedSketch(gridSpacing=0.002, name='__profile__',
			sheetSize=0.088, transform=
			mdb.models['Model-1'].parts['pipe'].MakeSketchTransform(
			sketchPlane=mdb.models['Model-1'].parts['pipe'].faces.findAt((0.001,
			0.0, 0.001), ), sketchPlaneSide=SIDE1,
			sketchUpEdge=mdb.models['Model-1'].parts['pipe'].edges.findAt((0.05, 0.0,
			0.001), ), sketchOrientation=RIGHT, origin=(0.025, 0.0, 0.0)))
		mdb.models['Model-1'].sketches['__profile__'].sketchOptions.setValues(decimalPlaces=3)
		mdb.models['Model-1'].parts['pipe'].projectReferencesOntoSketch(filter=
			COPLANAR_EDGES, sketch=mdb.models['Model-1'].sketches['__profile__'])
		mdb.models['Model-1'].sketches['__profile__'].ConstructionLine(angle=90.0, point1=(0.0, 0.0))

		# Save the construction line
		const_line_loss = mdb.models['Model-1'].sketches['__profile__'].geometry.findAt((0.0, 1.0))

		mdb.models['Model-1'].sketches['__profile__'].Line(point1=(0.0, 0.0),
			point2=(current_loss_width / 2, 0.0))
		mdb.models['Model-1'].sketches['__profile__'].Line(point1=(0.0, 0.0),
			point2=(0.0, current_loss_height))
		mdb.models['Model-1'].sketches['__profile__'].EllipseByCenterPerimeter(
			axisPoint1=(0.0, current_loss_height), axisPoint2=(current_loss_width / 2,
			0.0), center=(0.0, 0.0))
		mdb.models['Model-1'].sketches['__profile__'].breakCurve(curve1=
			mdb.models['Model-1'].sketches['__profile__'].geometry.findAt((-current_loss_width / 2,
			0.0), ), curve2=
			mdb.models['Model-1'].sketches['__profile__'].geometry.findAt((current_loss_height,
			0.0), ), point1=(-current_loss_width / 2, 0.0), point2=(current_loss_height, 0.0))
		mdb.models['Model-1'].sketches['__profile__'].delete(objectList=(
			mdb.models['Model-1'].sketches['__profile__'].geometry.findAt((-current_loss_width / 2,
			0.0), ), ))
		mdb.models['Model-1'].sketches['__profile__'].sketchOptions.setValues(
			constructionGeometry=ON)
		mdb.models['Model-1'].sketches['__profile__'].assignCenterline(line=
			mdb.models['Model-1'].sketches['__profile__'].geometry.findAt((0.0, 0.019 / 2), ))
		mdb.models['Model-1'].parts['pipe'].CutRevolve(angle=180.0,
			flipRevolveDirection=OFF, sketch=
			mdb.models['Model-1'].sketches['__profile__'], sketchOrientation=RIGHT,
			sketchPlane=mdb.models['Model-1'].parts['pipe'].faces.findAt((0.001,
			0.0, 0.001), ), sketchPlaneSide=SIDE1, sketchUpEdge=
			mdb.models['Model-1'].parts['pipe'].edges.findAt((0.05, 0.0, 0.001), ))
		del mdb.models['Model-1'].sketches['__profile__']

		# Create datum point based on the corrosion height
		mdb.models['Model-1'].parts['pipe'].DatumPointByCoordinate(coords=(0.0, 0.0, current_loss_height + part_y_wall))

		# Create additional crack
		if flaw_type == 5:
			mdb.models['Model-1'].ConstrainedSketch(gridSpacing=0.001, name='__profile__',sheetSize=0.044, transform=
				mdb.models['Model-1'].parts['pipe'].MakeSketchTransform(
				sketchPlane=mdb.models['Model-1'].parts['pipe'].faces.findAt((0.001,0.0,0.001), ),
				sketchPlaneSide=SIDE1,sketchUpEdge=mdb.models['Model-1'].parts['pipe'].edges.findAt((0.05,0.0,0.001), ),
				sketchOrientation=RIGHT, origin=(0.025, 0.0, 0.0095)))
			mdb.models['Model-1'].sketches['__profile__'].sketchOptions.setValues(decimalPlaces=3)
			mdb.models['Model-1'].parts['pipe'].projectReferencesOntoSketch(filter=
				COPLANAR_EDGES, sketch=mdb.models['Model-1'].sketches['__profile__'])
			mdb.models['Model-1'].sketches['__profile__'].ConstructionLine(point1=(current_horizontal_wc, 0.0095 - current_depth_2),
				point2=(-math.tan(current_angle_2) + current_horizontal_wc, 0.0095 - current_depth_2 + 1))

			# Save the construction line
			const_line_2 = mdb.models['Model-1'].sketches['__profile__'].geometry.findAt(
				(math.tan(current_angle_2) + current_horizontal_wc, 0.0095 - current_depth_2 - 1))

			mdb.models['Model-1'].sketches['__profile__'].EllipseByCenterPerimeter(
				axisPoint1=(-current_short_axis_2 * math.sin(current_angle_2) + current_horizontal_wc,
				current_short_axis_2 * math.cos(current_angle_2) + 0.0095 - current_depth_2),
				axisPoint2=(current_long_axis_2 * math.cos(current_angle_2) + current_horizontal_wc,
				current_long_axis_2 * math.sin(current_angle_2) + 0.0095 - current_depth_2), center=(
				current_horizontal_wc, 0.0095 - current_depth_2))
			mdb.models['Model-1'].sketches['__profile__'].breakCurve(
				curve1=mdb.models['Model-1'].sketches['__profile__'].geometry.findAt(
				(current_long_axis_2 * math.cos(current_angle_2) + current_horizontal_wc,
				current_long_axis_2 * math.sin(current_angle_2) + 0.0095 - current_depth_2)),
				curve2=const_line_2, point1=(current_long_axis_2 * math.cos(current_angle_2) + current_horizontal_wc,
				current_long_axis_2 * math.sin(current_angle_2) + 0.0095 - current_depth_2),
				point2=(0.0095 - current_depth_2 + 1 + current_horizontal_wc, -math.tan(current_angle_2)))
			mdb.models['Model-1'].sketches['__profile__'].delete(objectList=(
				mdb.models['Model-1'].sketches['__profile__'].geometry.findAt((
				-current_long_axis_2 * math.cos(current_angle_2) + current_horizontal_wc,
				-current_long_axis_2 * math.sin(current_angle_2) + 0.0095 - current_depth_2), ),))
			mdb.models['Model-1'].sketches['__profile__'].Line(
				point1=(-current_short_axis_2 * math.sin(current_angle_2) + current_horizontal_wc,
				current_short_axis_2 * math.cos(current_angle_2) + 0.0095 - current_depth_2),
				point2=(current_short_axis_2 * math.sin(current_angle_2) + current_horizontal_wc,
				-current_short_axis_2 * math.cos(current_angle_2) + 0.0095 - current_depth_2))
			mdb.models['Model-1'].sketches['__profile__'].sketchOptions.setValues(constructionGeometry=ON)
			mdb.models['Model-1'].sketches['__profile__'].assignCenterline(line=const_line_2)
			mdb.models['Model-1'].parts['pipe'].CutRevolve(angle=180.0,flipRevolveDirection=OFF, sketch=
				mdb.models['Model-1'].sketches['__profile__'],sketchOrientation=RIGHT,
				sketchPlane=mdb.models['Model-1'].parts['pipe'].faces.findAt((0.001, 0.0, 0.001), ),
				sketchPlaneSide=SIDE1, sketchUpEdge=mdb.models['Model-1'].parts['pipe'].edges.findAt((0.05, 0.0, 0.001),))
			del mdb.models['Model-1'].sketches['__profile__']

			# Create datum points based on the 2nd crack location
			mdb.models['Model-1'].parts['pipe'].DatumPointByCoordinate(coords=(0.0, 0.0, 0.019 - current_depth_2))
			mdb.models['Model-1'].parts['pipe'].DatumPointByCoordinate(coords=(0.0, 0.0, 0.019 - current_depth_2 + part_y_crack))
			mdb.models['Model-1'].parts['pipe'].DatumPointByCoordinate(coords=(0.0, 0.0, 0.019 - current_depth_2 - part_y_crack))
			if current_horizontal_wc > 0:
				mdb.models['Model-1'].parts['pipe'].DatumPointByCoordinate(coords=(
					0.025 + current_horizontal_wc + part_x_crack, 0.0, 0.0))
			else:
				mdb.models['Model-1'].parts['pipe'].DatumPointByCoordinate(coords=(
					0.025 + current_horizontal_wc - part_x_crack, 0.0, 0.0))

	"""Material properties and assembly"""
	mdb.models['Model-1'].Material(name='steel')
	mdb.models['Model-1'].materials['steel'].Density(table=((mat_density,),))
	mdb.models['Model-1'].materials['steel'].Elastic(table=((young_modulus, poisson_ratio),))
	mdb.models['Model-1'].HomogeneousSolidSection(material='steel', name='Section-1', thickness=None)
	mdb.models['Model-1'].parts['pipe'].SectionAssignment(offset=0.0, offsetField='', offsetType=MIDDLE_SURFACE,
		region=Region(cells=mdb.models['Model-1'].parts['pipe'].cells.findAt(((0.001, 0.001, 0.001),), )),
		sectionName='Section-1',thicknessAssignment=FROM_SECTION)
	mdb.models['Model-1'].rootAssembly.DatumCsysByDefault(CARTESIAN)
	if current_index == 1:
		mdb.models['Model-1'].rootAssembly.Instance(dependent=OFF, name='pipe-1',
			part=mdb.models['Model-1'].parts['pipe'])
	else:
		del mdb.models['Model-1'].rootAssembly.instances['pipe-1']
		mdb.models['Model-1'].rootAssembly.Instance(dependent=OFF, name='pipe-1',
			part=mdb.models['Model-1'].parts['pipe'])

	"""Partition, sets and meshing"""
	# Create set for the symmetry plane
	mdb.models['Model-1'].rootAssembly.Set(faces=
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].faces.findAt(((0.001, 0.0, 0.001),), ), name='sym_plane')

	# Partition the top surface for probe region
	mdb.models['Model-1'].ConstrainedSketch(gridSpacing=0.002, name='__profile__',
		sheetSize=0.111, transform=
		mdb.models['Model-1'].rootAssembly.MakeSketchTransform(
		sketchPlane=mdb.models['Model-1'].rootAssembly.instances['pipe-1'].faces.findAt(
		(0.001, 0.001, 0.019), ), sketchPlaneSide=SIDE1,
		sketchUpEdge=mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(
		(0.05, 0.001, 0.019), ), sketchOrientation=RIGHT, origin=(0.025, 0.0, 0.019)))
	mdb.models['Model-1'].sketches['__profile__'].sketchOptions.setValues(
		decimalPlaces=3)
	mdb.models['Model-1'].rootAssembly.projectReferencesOntoSketch(filter=
		COPLANAR_EDGES, sketch=mdb.models['Model-1'].sketches['__profile__'])
	mdb.models['Model-1'].sketches['__profile__'].ArcByCenterEnds(center=(0.0,
		0.0), direction=CLOCKWISE, point1=(-0.003, 0.0), point2=(0.003, 0.0))
	mdb.models['Model-1'].sketches['__profile__'].ArcByCenterEnds(center=(0.0,
		0.0), direction=CLOCKWISE, point1=(-0.014, 0.0), point2=(0.014, 0.0))
	mdb.models['Model-1'].rootAssembly.PartitionFaceBySketch(faces=
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].faces.findAt(((
		0.001, 0.001, 0.019), )), sketch=
		mdb.models['Model-1'].sketches['__profile__'], sketchUpEdge=
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt((0.05,
		0.001, 0.019), ))
	del mdb.models['Model-1'].sketches['__profile__']

	# Create surface and set for the exciter
	mdb.models['Model-1'].rootAssembly.Surface(name='Exciter',
		side1Faces=mdb.models['Model-1'].rootAssembly.instances['pipe-1'].faces.findAt(((0.025, 0.001, 0.019), )))
	mdb.models['Model-1'].rootAssembly.Set(faces=
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].faces.findAt(((0.025, 0.001, 0.019),), ), name='Sensor')

	# Save axes based on those defined in parts module
	datum_x = mdb.models['Model-1'].rootAssembly.instances['pipe-1'].datums[2]
	datum_y = mdb.models['Model-1'].rootAssembly.instances['pipe-1'].datums[3]
	datum_z = mdb.models['Model-1'].rootAssembly.instances['pipe-1'].datums[4]

	# Partition out the coarse mesh region
	mdb.models['Model-1'].rootAssembly.PartitionCellByExtrudeEdge(cells=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(((
			0.001, 0.001, 0.001), )), edges=(
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt((
			0.025, 0.014, 0.019), ), ), line=datum_z, sense=REVERSE)

	# Partition the pipe for different cases
	if flaw_type == 2:
		# Save datum points/axis based on those defined in parts module
		crack_center_1 = mdb.models['Model-1'].rootAssembly.instances['pipe-1'].datums[6]
		crack_top_1 = mdb.models['Model-1'].rootAssembly.instances['pipe-1'].datums[7]
		crack_bot_1 = mdb.models['Model-1'].rootAssembly.instances['pipe-1'].datums[8]

		# Partition the top region
		mdb.models['Model-1'].rootAssembly.PartitionCellByExtrudeEdge(cells=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(((
			0.025, 0.001, 0.001), )), edges=(
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt((
			0.025, 0.003, 0.019), ), ), line=datum_z, sense=REVERSE)

		# Partition for the crack
		mdb.models['Model-1'].rootAssembly.PartitionCellByPlanePointNormal(cells=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(
			((0.025, 0.001, 0.001),)), normal=datum_z, point=crack_top_1)

		mdb.models['Model-1'].rootAssembly.PartitionCellByPlanePointNormal(cells=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(
			((0.025, 0.001, crack_top_1.pointOn[2] - 0.001),)), normal=datum_z, point=crack_bot_1)

		## Assign seed
		# Global seed
		mdb.models['Model-1'].rootAssembly.seedPartInstance(deviationFactor=0.1,minSizeFactor=0.1, regions=(
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'],), size=mesh_size_general)

		# Single biased seed for connection regions, from 0.0001 to 0.0008
		mdb.models['Model-1'].rootAssembly.seedEdgeByBias(biasMethod=SINGLE,constraint=FINER, end1Edges=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(((0.0111, 0.0, 0.0),),
			((0.0111, 0.0, 0.019),), ), maxSize=mesh_size_coarse/2, minSize=mesh_size_general)
		mdb.models['Model-1'].rootAssembly.seedEdgeByBias(biasMethod=SINGLE,constraint=FINER, end2Edges=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(((0.0389, 0.0, 0.0),),
			((0.0389, 0.0, 0.019),), ), maxSize=mesh_size_coarse/2, minSize=mesh_size_general)

		# Seed for connection region, two semi-circles
		mdb.models['Model-1'].rootAssembly.seedEdgeBySize(constraint=FREE, deviationFactor=0.5, edges=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(
			((0.025, 0.014, 0.0),), ((0.025, 0.014, 0.019),)),
			minSizeFactor=0.1, size=mesh_size_coarse)

		# Seed for out region
		mdb.models['Model-1'].rootAssembly.seedEdgeBySize(constraint=FREE, deviationFactor=0.5, edges=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(
			((0.001, 0.0, 0.0),), ((0.049, 0.0, 0.0),), ((0.0, 0.01, 0.0),), ((0.05, 0.01, 0.0),), ((0.025, 0.025, 0.0),)),
			minSizeFactor=0.1, size=mesh_size_coarse)

		# Seed the crack perimeter by controlling the minimum size
		mdb.models['Model-1'].rootAssembly.seedEdgeBySize(constraint=FINER, deviationFactor=0.8, edges=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(
			((0.025 + current_long_axis_1 * math.cos(current_angle_1), 0.0,
			  0.019 - current_depth_1 + current_long_axis_1 * math.sin(current_angle_1)),),
			((0.025 - current_long_axis_1 * math.cos(current_angle_1), 0.0,
			  0.019 - current_depth_1 - current_long_axis_1 * math.sin(current_angle_1)),)),
			minSizeFactor=0.8, size=mesh_size_general)

		# Partition the ellip crack face for better meshing result
		mdb.models['Model-1'].rootAssembly.PartitionFaceByShortestPath(faces=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].faces.findAt(((
			0.025, current_long_axis_1, 0.019 - current_depth_1),)), point1=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].InterestingPoint(
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt((
			0.025 + current_long_axis_1 * math.cos(current_angle_1), 0.0,
			0.019 - current_depth_1 + current_long_axis_1 * math.sin(current_angle_1)), ),
			MIDDLE), point2=mdb.models['Model-1'].rootAssembly.instances['pipe-1'].InterestingPoint(
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt((
			0.025 - current_long_axis_1 * math.cos(current_angle_1), 0.0,
			0.019 - current_depth_1 - current_long_axis_1 * math.sin(current_angle_1)), ), MIDDLE))

		# Seed the crack perimeter
		mdb.models['Model-1'].rootAssembly.seedEdgeBySize(constraint=FINER, deviationFactor=0.8, edges=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(
			((0.025, current_long_axis_1, 0.019 - current_depth_1),)),
			minSizeFactor=0.8, size=mesh_size_general)

		# Set Tet element type for the crack region
		mdb.models['Model-1'].rootAssembly.setMeshControls(elemShape=TET, regions=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(((0.025,
			0.0025, crack_top_1.pointOn[2] - 0.0001),)), sizeGrowthRate=1.2,technique=FREE)

		mdb.models['Model-1'].rootAssembly.setElementType(elemTypes=(ElemType(
			elemCode=UNKNOWN_HEX, elemLibrary=EXPLICIT), ElemType(
			elemCode=UNKNOWN_WEDGE, elemLibrary=EXPLICIT), ElemType(elemCode=C3D10M,
			elemLibrary=EXPLICIT, secondOrderAccuracy=OFF,distortionControl=DEFAULT)),
			regions=(mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(
			((0.025, 0.0025, crack_top_1.pointOn[2] - 0.0001),)),))

		# Set the probe region to medial axis meshing
		mdb.models['Model-1'].rootAssembly.setMeshControls(algorithm=MEDIAL_AXIS,
			regions=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(((
			0.025, 0.001, 0.0189), ), ((0.025, 0.001, 0.001), )), sizeGrowthRate=1.2)

		## Mesh regions
		# Mesh the center region except the crack partition
		mdb.models['Model-1'].rootAssembly.generateMesh(regions=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(
			((0.025, 0.00001, crack_top_1.pointOn[2] + 0.001),), ((0.025, 0.00001, crack_bot_1.pointOn[2] - 0.001),)))

		# Mesh the connection region
		mdb.models['Model-1'].rootAssembly.generateMesh(regions=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(
			((0.0111, 0.001, 0.018),)))

		# Mesh the out region
		mdb.models['Model-1'].rootAssembly.generateMesh(regions=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(
			((0.001, 0.001, 0.018),)))

		# Mesh the crack region
		mdb.models['Model-1'].rootAssembly.generateMesh(regions=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(
			((0.025, 0.001, crack_top_1.pointOn[2] - 0.001),)))

	elif flaw_type == 3:
		# Save datum points/axis based on those defined in parts module
		crack_center_1 = mdb.models['Model-1'].rootAssembly.instances['pipe-1'].datums[6]
		crack_top_1 =  mdb.models['Model-1'].rootAssembly.instances['pipe-1'].datums[7]
		crack_bot_1 = mdb.models['Model-1'].rootAssembly.instances['pipe-1'].datums[8]
		crack_center_2 = mdb.models['Model-1'].rootAssembly.instances['pipe-1'].datums[10]
		crack_top_2 = mdb.models['Model-1'].rootAssembly.instances['pipe-1'].datums[11]
		crack_bot_2 = mdb.models['Model-1'].rootAssembly.instances['pipe-1'].datums[12]
		crack_boundary = mdb.models['Model-1'].rootAssembly.instances['pipe-1'].datums[13]

		# Partition the top face for addtional arc containing the crack
		if abs(current_horizontal_cc) > 0.0003:
			mdb.models['Model-1'].ConstrainedSketch(gridSpacing=0.002, name='__profile__',
				sheetSize=0.111, transform=
				mdb.models['Model-1'].rootAssembly.MakeSketchTransform(
				sketchPlane=mdb.models['Model-1'].rootAssembly.instances['pipe-1'].faces.findAt(
				(0.025, 0.0139, 0.019), ), sketchPlaneSide=SIDE1,
				sketchUpEdge=mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(
				(0.05, 0.001, 0.019), ), sketchOrientation=RIGHT, origin=(0.025, 0.0, 0.019)))
			mdb.models['Model-1'].sketches['__profile__'].sketchOptions.setValues(
				decimalPlaces=3)
			mdb.models['Model-1'].rootAssembly.projectReferencesOntoSketch(filter=
				COPLANAR_EDGES, sketch=mdb.models['Model-1'].sketches['__profile__'])
			mdb.models['Model-1'].sketches['__profile__'].ArcByCenterEnds(center=(0.0,
				0.0), direction=CLOCKWISE, point1=(-abs(crack_boundary.pointOn[0] - 0.025), 0.0),
				point2=(abs(crack_boundary.pointOn[0] - 0.025), 0.0))
			mdb.models['Model-1'].rootAssembly.PartitionFaceBySketch(faces=
				mdb.models['Model-1'].rootAssembly.instances['pipe-1'].faces.findAt(((
				0.025, 0.0139, 0.019), )), sketch=
				mdb.models['Model-1'].sketches['__profile__'], sketchUpEdge=
				mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt((0.05, 0.001, 0.019), ))
			del mdb.models['Model-1'].sketches['__profile__']

		# Partition above the crack
		if crack_top_2.pointOn[2] > crack_top_1.pointOn[2]:
			top_point = crack_top_2
		else:
			top_point = crack_top_1

		if crack_bot_2.pointOn[2] > crack_bot_1.pointOn[2]:
			bot_point = crack_bot_1
		else:
			bot_point = crack_bot_2

		mdb.models['Model-1'].rootAssembly.PartitionCellByPlanePointNormal(cells=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(
			((0.025, 0.001, 0.0189),)), normal=datum_z, point=top_point)

		# Partition above the crack
		mdb.models['Model-1'].rootAssembly.PartitionCellByPlanePointNormal(cells=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(
			((0.025, 0.001, 0.001),)), normal=datum_z, point=bot_point)

		# Partition for the crack boundary
		if abs(current_horizontal_cc) > 0.0003:
			mdb.models['Model-1'].rootAssembly.PartitionCellByExtrudeEdge(cells=
				mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(((
				0.025, 0.001, 0.0189), ), ((0.025, 0.001, crack_top_2.pointOn[2] - 0.0001), ),
				((0.025, 0.001, 0.0001), )), edges=(
				mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt((
				0.025, abs(crack_boundary.pointOn[0] - 0.025), 0.019), ), ), line=datum_z, sense=REVERSE)

			# Partition for the probe region
			mdb.models['Model-1'].rootAssembly.PartitionCellByExtrudeEdge(cells=
				mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(((
				0.025, 0.001, 0.0189), )), edges=(
				mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt((
				0.025, 0.003, 0.019), ), ), line=datum_z, sense=REVERSE)
		else:
			# Partition for the probe region
			mdb.models['Model-1'].rootAssembly.PartitionCellByExtrudeEdge(cells=
				mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(((
				0.025, 0.001, 0.0189), ), ((0.025, 0.001, crack_top_2.pointOn[2] - 0.0001), )), edges=(
				mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt((
				0.025, 0.003, 0.019), ), ), line=datum_z, sense=REVERSE)

		## Assign seed
		# Global seed
		mdb.models['Model-1'].rootAssembly.seedPartInstance(deviationFactor=0.1,minSizeFactor=0.1, regions=(
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'],), size=mesh_size_general)

		# Single biased seed for connection regions, from 0.0001 to 0.0008
		mdb.models['Model-1'].rootAssembly.seedEdgeByBias(biasMethod=SINGLE,constraint=FINER, end1Edges=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(((0.0111, 0.0, 0.019),),
			((0.0389, 0.0, top_point.pointOn[2]),), ((0.0389, 0.0, bot_point.pointOn[2]),), ((0.0111, 0.0, 0.0),)),
			maxSize=mesh_size_coarse/2, minSize=mesh_size_general)
		mdb.models['Model-1'].rootAssembly.seedEdgeByBias(biasMethod=SINGLE,constraint=FINER, end2Edges=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(((0.0389, 0.0, 0.019),),
			((0.0111, 0.0, top_point.pointOn[2]),), ((0.0111, 0.0, bot_point.pointOn[2]),), ((0.0389, 0.0, 0.0),)),
			maxSize=mesh_size_coarse/2, minSize=mesh_size_general)

		# Seed for connection region, four semi-circles
		mdb.models['Model-1'].rootAssembly.seedEdgeBySize(constraint=FREE, deviationFactor=0.5, edges=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(
			((0.025, 0.014, top_point.pointOn[2]),), ((0.025, 0.014, bot_point.pointOn[2]),), ((0.025, 0.014, 0.019),),
			((0.025, 0.014, 0.0),)), minSizeFactor=0.1, size=mesh_size_coarse)

		# Seed for out region
		mdb.models['Model-1'].rootAssembly.seedEdgeBySize(constraint=FREE, deviationFactor=0.5, edges=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(
			((0.001, 0.0, 0.0),), ((0.049, 0.0, 0.0),), ((0.0, 0.01, 0.019),), ((0.05, 0.01, 0.019),), ((0.025, 0.025, 0.019),)),
			minSizeFactor=0.1, size=mesh_size_coarse)

		# Seed the crack perimeter by controlling the minimum size
		mdb.models['Model-1'].rootAssembly.seedEdgeBySize(constraint=FINER, deviationFactor=0.8, edges=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(
			((0.025 +current_long_axis_1 * math.cos(current_angle_1), 0.0,
			  0.019 - current_depth_1 + current_long_axis_1 * math.sin(current_angle_1)),),
			((0.025 - current_long_axis_1 * math.cos(current_angle_1), 0.0,
			  0.019 - current_depth_1 - current_long_axis_1 * math.sin(current_angle_1)),)),
			minSizeFactor=0.8, size=mesh_size_general)
		mdb.models['Model-1'].rootAssembly.seedEdgeBySize(constraint=FINER, deviationFactor=0.8, edges=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(
			((0.025 + current_horizontal_cc + current_long_axis_2 * math.cos(current_angle_2), 0.0,
			  0.019 - current_depth_2 + current_long_axis_2 * math.sin(current_angle_2)),),
			((0.025 + current_horizontal_cc - current_long_axis_2 * math.cos(current_angle_2), 0.0,
			  0.019 - current_depth_2 - current_long_axis_2 * math.sin(current_angle_2)),)),
			minSizeFactor=0.8, size=mesh_size_general)

		## Put an additional check point here to see if the two cracks intersect by checking the four long axis points exsit
		try:
			pt1 = mdb.models['Model-1'].rootAssembly.instances['pipe-1'].InterestingPoint(
				mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt((
				0.025 + current_long_axis_1 * math.cos(current_angle_1), 0.0,
				0.019 - current_depth_1 + current_long_axis_1 * math.sin(current_angle_1)), ),MIDDLE)
			pt2 = mdb.models['Model-1'].rootAssembly.instances['pipe-1'].InterestingPoint(
				mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt((
				0.025 - current_long_axis_1 * math.cos(current_angle_1), 0.0,
				0.019 - current_depth_1 - current_long_axis_1 * math.sin(current_angle_1)), ), MIDDLE)
			pt3 = mdb.models['Model-1'].rootAssembly.instances['pipe-1'].InterestingPoint(
				mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt((
				0.025 + current_horizontal_cc + current_long_axis_2 * math.cos(current_angle_2), 0.0,
				0.019 - current_depth_2 + current_long_axis_2 * math.sin(current_angle_2)), ),MIDDLE)
			pt4 = mdb.models['Model-1'].rootAssembly.instances['pipe-1'].InterestingPoint(
				mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt((
				0.025 + current_horizontal_cc - current_long_axis_2 * math.cos(current_angle_2), 0.0,
				0.019 - current_depth_2 - current_long_axis_2 * math.sin(current_angle_2)), ), MIDDLE)
		except:
			pass
		else:
			# Partition the ellip crack face for better meshing result
			mdb.models['Model-1'].rootAssembly.PartitionFaceByShortestPath(faces=
				mdb.models['Model-1'].rootAssembly.instances['pipe-1'].faces.findAt(((
				0.025, current_long_axis_1, 0.019 - current_depth_1),)), point1=
				mdb.models['Model-1'].rootAssembly.instances['pipe-1'].InterestingPoint(
				mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt((
				0.025 + current_long_axis_1 * math.cos(current_angle_1), 0.0,
				0.019 - current_depth_1 + current_long_axis_1 * math.sin(current_angle_1)), ), MIDDLE), point2=
				mdb.models['Model-1'].rootAssembly.instances['pipe-1'].InterestingPoint(
				mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt((
				0.025 - current_long_axis_1 * math.cos(current_angle_1), 0.0,
				0.019 - current_depth_1 - current_long_axis_1 * math.sin(current_angle_1)), ), MIDDLE))
			mdb.models['Model-1'].rootAssembly.PartitionFaceByShortestPath(faces=
				mdb.models['Model-1'].rootAssembly.instances['pipe-1'].faces.findAt(((
				0.025 + current_horizontal_cc, current_long_axis_2, 0.019 - current_depth_2),)),
				point1=mdb.models['Model-1'].rootAssembly.instances['pipe-1'].InterestingPoint(
				mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt((
				0.025 + current_horizontal_cc + current_long_axis_2 * math.cos(current_angle_2), 0.0,
				0.019 - current_depth_2 + current_long_axis_2 * math.sin(current_angle_2)), ),MIDDLE), point2=
				mdb.models['Model-1'].rootAssembly.instances['pipe-1'].InterestingPoint(
				mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt((
				0.025 + current_horizontal_cc - current_long_axis_2 * math.cos(current_angle_2), 0.0,
				0.019 - current_depth_2 - current_long_axis_2 * math.sin(current_angle_2)), ), MIDDLE))

			# Seed the crack perimeter
			mdb.models['Model-1'].rootAssembly.seedEdgeBySize(constraint=FINER, deviationFactor=0.8, edges=
				mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(
				((0.025, current_long_axis_1, 0.019 - current_depth_1),)),
				minSizeFactor=0.8, size=mesh_size_general)
			mdb.models['Model-1'].rootAssembly.seedEdgeBySize(constraint=FINER, deviationFactor=0.8, edges=
				mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(
				((0.025 + current_horizontal_cc, current_long_axis_2, 0.019 - current_depth_2),)),
				minSizeFactor=0.8, size=mesh_size_general)

			# Set Tet element type for the crack region
			mdb.models['Model-1'].rootAssembly.setMeshControls(elemShape=TET, regions=
				mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(((0.025,
				0.001, top_point.pointOn[2] - 0.0001),)), sizeGrowthRate=1.2,technique=FREE)

			mdb.models['Model-1'].rootAssembly.setElementType(elemTypes=(ElemType(
				elemCode=UNKNOWN_HEX, elemLibrary=EXPLICIT), ElemType(
				elemCode=UNKNOWN_WEDGE, elemLibrary=EXPLICIT), ElemType(elemCode=C3D10M,
				elemLibrary=EXPLICIT, secondOrderAccuracy=OFF,distortionControl=DEFAULT)),
				regions=(mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(
				((0.025, 0.001, top_point.pointOn[2] - 0.0001),)),))

			# Set the probe region to medial axis meshing
			mdb.models['Model-1'].rootAssembly.setMeshControls(algorithm=MEDIAL_AXIS,
				regions=
				mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(((
				0.025, 0.001, 0.0189), )), sizeGrowthRate=1.2)

			## Mesh regions
			# Mesh the center region
			mdb.models['Model-1'].rootAssembly.generateMesh(regions=
				mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(
				((0.025, 0.001, 0.0189),)))

			# Mesh the small connection region
			mdb.models['Model-1'].rootAssembly.generateMesh(regions=
				mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(
				((0.0281, 0.0001, 0.0189),)))

			# Mesh the upper connection region
			mdb.models['Model-1'].rootAssembly.generateMesh(regions=
				mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(
				((0.0111, 0.0001, 0.0189),)))

			# Mesh the middle connection region
			mdb.models['Model-1'].rootAssembly.generateMesh(regions=
				mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(
				((0.0111, 0.0001, top_point.pointOn[2] - 0.0001),)))

			# Mesh the lower connection region
			mdb.models['Model-1'].rootAssembly.generateMesh(regions=
				mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(
				((0.0111, 0.0001, 0.0001),)))

			# Mesh the bottom region
			mdb.models['Model-1'].rootAssembly.generateMesh(regions=
				mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(
				((0.025, 0.0001, 0.0001),)))

			# Mesh the crack region
			mdb.models['Model-1'].rootAssembly.generateMesh(regions=
				mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(
				((0.025, 0.0001, top_point.pointOn[2] - 0.0001),)))

			# Mesh the out region
			mdb.models['Model-1'].rootAssembly.generateMesh(regions=
				mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(
				((0.001, 0.001, 0.018),), ((0.001, 0.001, 0.001),)))

	elif flaw_type == 4:
		# Create a datum point for loss height
		corr_top = mdb.models['Model-1'].rootAssembly.instances['pipe-1'].datums[6]

		# Partition for the corrosion
		mdb.models['Model-1'].rootAssembly.PartitionCellByPlanePointNormal(cells=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(
			((0.025, 0.001, 0.0189),), ((0.001, 0.001, 0.0189),)), normal=datum_z, point=corr_top)

		# Partition for the center region
		mdb.models['Model-1'].rootAssembly.PartitionCellByExtrudeEdge(cells=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(((
			0.025, 0.001, 0.0189), )), edges=(
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt((
			0.025, 0.003, 0.019), ), ), line=datum_z, sense=REVERSE)

		## Assign seed
		# Global seed
		mdb.models['Model-1'].rootAssembly.seedPartInstance(deviationFactor=0.1,minSizeFactor=0.1, regions=(
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'],), size=mesh_size_general)

		# Single biased seed for connection regions, from 0.0001 to 0.0008
		mdb.models['Model-1'].rootAssembly.seedEdgeByBias(biasMethod=SINGLE,constraint=FINER, end1Edges=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(((0.0111, 0.0, 0.019),),
			((0.0389, 0.0, corr_top.pointOn[2]),), ), maxSize=mesh_size_coarse/2, minSize=mesh_size_general)
		mdb.models['Model-1'].rootAssembly.seedEdgeByBias(biasMethod=SINGLE,constraint=FINER, end2Edges=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(((0.0389, 0.0, 0.019),),
			((0.0111, 0.0, corr_top.pointOn[2]),), ), maxSize=mesh_size_coarse/2, minSize=mesh_size_general)

		# Seed for connection region, two semi-circles
		mdb.models['Model-1'].rootAssembly.seedEdgeBySize(constraint=FREE, deviationFactor=0.5, edges=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(
			((0.025, 0.014, corr_top.pointOn[2]),), ((0.025, 0.014, 0.019),)),
			minSizeFactor=0.1, size=mesh_size_coarse)

		# Seed for out region
		mdb.models['Model-1'].rootAssembly.seedEdgeBySize(constraint=FREE, deviationFactor=0.5, edges=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(
			((0.001, 0.0, 0.019),), ((0.049, 0.0, 0.019),), ((0.0, 0.01, 0.019),), ((0.05, 0.01, 0.019),), ((0.025, 0.025, 0.019),)),
			minSizeFactor=0.1, size=mesh_size_coarse)

		# Seed for the bottom z axis
		mdb.models['Model-1'].rootAssembly.seedEdgeBySize(constraint=FREE, deviationFactor=0.1, edges=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(((0.0, 0.0, 0.001),)),
			minSizeFactor=0.1, size=mesh_size_coarse/4)

		# Seed for bottom partition radius edge
		mdb.models['Model-1'].rootAssembly.seedEdgeBySize(constraint=FREE, deviationFactor=0.5, edges=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(((0.025, 0.014, 0.0),)),
			minSizeFactor=0.1, size=mesh_size_coarse/2)

		# Seed for corrosion radius edge
		mdb.models['Model-1'].rootAssembly.seedEdgeBySize(constraint=FINER, deviationFactor=0.5, edges=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(((0.025, current_loss_width/2, 0.0),)),
			minSizeFactor=0.1, size=mesh_size_coarse/4)

		# Seed for corrosion height edge
		mdb.models['Model-1'].rootAssembly.seedEdgeByBias(biasMethod=SINGLE,constraint=FINER, end2Edges=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(((0.0249, 0.0, current_loss_height),),
			), maxSize=mesh_size_coarse/8, minSize=mesh_size_general)
		mdb.models['Model-1'].rootAssembly.seedEdgeByBias(biasMethod=SINGLE,constraint=FINER, end1Edges=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(((0.0251, 0.0, current_loss_height),),
			), maxSize=mesh_size_coarse/8, minSize=mesh_size_general)

		# Seed for bottom x direction edges
		mdb.models['Model-1'].rootAssembly.seedEdgeBySize(constraint=FREE, deviationFactor=0.1, edges=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(((0.0111, 0.0, 0.0),), ((0.0389, 0.0, 0.0),)),
			minSizeFactor=0.1, size=mesh_size_coarse/4)

		# Set Tet element type for the crack region
		mdb.models['Model-1'].rootAssembly.setMeshControls(elemShape=TET, regions=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(((0.025,
			0.001, corr_top.pointOn[2] - 0.0001),)), sizeGrowthRate=1.2,technique=FREE)

		mdb.models['Model-1'].rootAssembly.setElementType(elemTypes=(ElemType(
			elemCode=UNKNOWN_HEX, elemLibrary=EXPLICIT), ElemType(
			elemCode=UNKNOWN_WEDGE, elemLibrary=EXPLICIT), ElemType(elemCode=C3D10M,
			elemLibrary=EXPLICIT, secondOrderAccuracy=OFF,distortionControl=DEFAULT)),
			regions=(mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(
			((0.025, 0.001, corr_top.pointOn[2] - 0.0001),)),))

		# Set the probe region to medial axis meshing
		mdb.models['Model-1'].rootAssembly.setMeshControls(algorithm=MEDIAL_AXIS,
			regions=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(((
			0.025, 0.001, 0.0189), )), sizeGrowthRate=1.2)

		## Mesh regions
		# Mesh the center region
		mdb.models['Model-1'].rootAssembly.generateMesh(regions=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(
			((0.025, 0.001, 0.0189),)))

		# Mesh the connection region
		mdb.models['Model-1'].rootAssembly.generateMesh(regions=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(
			((0.0111, 0.001, 0.018),)))

		# Mesh the corrosion region
		mdb.models['Model-1'].rootAssembly.generateMesh(regions=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(
			((0.025, 0.001, corr_top.pointOn[2] - 0.001),)))

		# Mesh the out region
		mdb.models['Model-1'].rootAssembly.generateMesh(regions=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(
			((0.001, 0.001, 0.018),), ((0.001, 0.001, 0.001),)))

	elif flaw_type == 5:
		# Create datum points for corrosion and crack
		corr_top = mdb.models['Model-1'].rootAssembly.instances['pipe-1'].datums[6]
		crack_center_2 = mdb.models['Model-1'].rootAssembly.instances['pipe-1'].datums[8]
		crack_top_2 = mdb.models['Model-1'].rootAssembly.instances['pipe-1'].datums[9]
		crack_bot_2 = mdb.models['Model-1'].rootAssembly.instances['pipe-1'].datums[10]
		crack_boundary = mdb.models['Model-1'].rootAssembly.instances['pipe-1'].datums[11]

		# Partition the top face for addtional arc containing the crack
		if abs(current_horizontal_wc) > 0.0003:
			mdb.models['Model-1'].ConstrainedSketch(gridSpacing=0.002, name='__profile__',
				sheetSize=0.111, transform=
				mdb.models['Model-1'].rootAssembly.MakeSketchTransform(
				sketchPlane=mdb.models['Model-1'].rootAssembly.instances['pipe-1'].faces.findAt(
				(0.025, 0.0139, 0.019), ), sketchPlaneSide=SIDE1,
				sketchUpEdge=mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(
				(0.05, 0.001, 0.019), ), sketchOrientation=RIGHT, origin=(0.025, 0.0, 0.019)))
			mdb.models['Model-1'].sketches['__profile__'].sketchOptions.setValues(
				decimalPlaces=3)
			mdb.models['Model-1'].rootAssembly.projectReferencesOntoSketch(filter=
				COPLANAR_EDGES, sketch=mdb.models['Model-1'].sketches['__profile__'])
			mdb.models['Model-1'].sketches['__profile__'].ArcByCenterEnds(center=(0.0,
				0.0), direction=CLOCKWISE, point1=(-abs(crack_boundary.pointOn[0] - 0.025), 0.0),
				point2=(abs(crack_boundary.pointOn[0] - 0.025), 0.0))
			mdb.models['Model-1'].rootAssembly.PartitionFaceBySketch(faces=
				mdb.models['Model-1'].rootAssembly.instances['pipe-1'].faces.findAt(((
				0.025, 0.0139, 0.019), )), sketch=
				mdb.models['Model-1'].sketches['__profile__'], sketchUpEdge=
				mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt((0.05, 0.001, 0.019), ))
			del mdb.models['Model-1'].sketches['__profile__']

		# Partition for the corrosion
		mdb.models['Model-1'].rootAssembly.PartitionCellByPlanePointNormal(cells=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(
			((0.025, 0.001, 0.0189),), ((0.001, 0.001, 0.0189),)), normal=datum_z, point=corr_top)

		# Partition above the crack
		mdb.models['Model-1'].rootAssembly.PartitionCellByPlanePointNormal(cells=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(
			((0.025, 0.001, 0.0189),)), normal=datum_z, point=crack_top_2)

		# Partition for the crack boundary
		if abs(current_horizontal_wc) > 0.0003:
			mdb.models['Model-1'].rootAssembly.PartitionCellByExtrudeEdge(cells=
				mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(((
				0.025, 0.001, 0.0189), ), ((0.025, 0.001, crack_top_2.pointOn[2] - 0.0001), )), edges=(
				mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt((
				0.025, abs(crack_boundary.pointOn[0] - 0.025), 0.019), ), ), line=datum_z, sense=REVERSE)

			# Partition for the probe region
			mdb.models['Model-1'].rootAssembly.PartitionCellByExtrudeEdge(cells=
				mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(((
				0.025, 0.001, 0.0189), )), edges=(
				mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt((
				0.025, 0.003, 0.019), ), ), line=datum_z, sense=REVERSE)
		else:
			# Partition for the probe region
			mdb.models['Model-1'].rootAssembly.PartitionCellByExtrudeEdge(cells=
				mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(((
				0.025, 0.001, 0.0189), ), ((0.025, 0.001, crack_top_2.pointOn[2] - 0.0001), )), edges=(
				mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt((
				0.025, 0.003, 0.019), ), ), line=datum_z, sense=REVERSE)

		## Assign seed
		# Global seed
		mdb.models['Model-1'].rootAssembly.seedPartInstance(deviationFactor=0.1,minSizeFactor=0.1, regions=(
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'],), size=mesh_size_general)

		# Single biased seed for connection regions, from 0.0001 to 0.0008
		mdb.models['Model-1'].rootAssembly.seedEdgeByBias(biasMethod=SINGLE,constraint=FINER, end1Edges=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(((0.0111, 0.0, 0.019),),
			((0.0389, 0.0, corr_top.pointOn[2]),), ((0.0389, 0.0, crack_top_2.pointOn[2]),)),
			maxSize=mesh_size_coarse/2, minSize=mesh_size_general)
		mdb.models['Model-1'].rootAssembly.seedEdgeByBias(biasMethod=SINGLE,constraint=FINER, end2Edges=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(((0.0389, 0.0, 0.019),),
			((0.0111, 0.0, corr_top.pointOn[2]),), ((0.0111, 0.0, crack_top_2.pointOn[2]),)),
			maxSize=mesh_size_coarse/2, minSize=mesh_size_general)

		# Seed for connection region, three semi-circles
		mdb.models['Model-1'].rootAssembly.seedEdgeBySize(constraint=FREE, deviationFactor=0.5, edges=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(
			((0.025, 0.014, crack_top_2.pointOn[2]),), ((0.025, 0.014, corr_top.pointOn[2]),), ((0.025, 0.014, 0.019),)),
			minSizeFactor=0.1, size=mesh_size_coarse)

		# Seed for out region
		mdb.models['Model-1'].rootAssembly.seedEdgeBySize(constraint=FREE, deviationFactor=0.5, edges=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(
			((0.001, 0.0, 0.019),), ((0.049, 0.0, 0.019),), ((0.0, 0.01, 0.019),), ((0.05, 0.01, 0.019),), ((0.025, 0.025, 0.019),)),
			minSizeFactor=0.1, size=mesh_size_coarse)

		# Seed for the bottom z axis
		mdb.models['Model-1'].rootAssembly.seedEdgeBySize(constraint=FREE, deviationFactor=0.1, edges=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(((0.0, 0.0, 0.001),)),
			minSizeFactor=0.1, size=mesh_size_coarse/4)

		# Seed for bottom partition radius edge
		mdb.models['Model-1'].rootAssembly.seedEdgeBySize(constraint=FREE, deviationFactor=0.5, edges=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(((0.025, 0.014, 0.0),)),
			minSizeFactor=0.1, size=mesh_size_coarse/2)

		# Seed for corrosion radius edge
		mdb.models['Model-1'].rootAssembly.seedEdgeBySize(constraint=FINER, deviationFactor=0.5, edges=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(((0.025, current_loss_width/2, 0.0),)),
			minSizeFactor=0.1, size=mesh_size_coarse/4)

		# Seed for corrosion height edge
		mdb.models['Model-1'].rootAssembly.seedEdgeByBias(biasMethod=SINGLE,constraint=FINER, end2Edges=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(((0.0249, 0.0, current_loss_height),),
			), maxSize=mesh_size_coarse/8, minSize=mesh_size_general)
		mdb.models['Model-1'].rootAssembly.seedEdgeByBias(biasMethod=SINGLE,constraint=FINER, end1Edges=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(((0.0251, 0.0, current_loss_height),),
			), maxSize=mesh_size_coarse/8, minSize=mesh_size_general)

		# Seed for bottom x direction edges
		mdb.models['Model-1'].rootAssembly.seedEdgeBySize(constraint=FREE, deviationFactor=0.1, edges=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(((0.0111, 0.0, 0.0),), ((0.0389, 0.0, 0.0),)),
			minSizeFactor=0.1, size=mesh_size_coarse/4)

		# Seed the crack perimeter by controlling the minimum size
		mdb.models['Model-1'].rootAssembly.seedEdgeBySize(constraint=FINER, deviationFactor=0.8, edges=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(
			((0.025 + current_horizontal_wc + current_long_axis_2 * math.cos(current_angle_2), 0.0,
			  0.019 - current_depth_2 + current_long_axis_2 * math.sin(current_angle_2)),),
			((0.025 + current_horizontal_wc - current_long_axis_2 * math.cos(current_angle_2), 0.0,
			  0.019 - current_depth_2 - current_long_axis_2 * math.sin(current_angle_2)),)),
			minSizeFactor=0.8, size=mesh_size_general)

		# Partition the ellip crack face for better meshing result
		mdb.models['Model-1'].rootAssembly.PartitionFaceByShortestPath(faces=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].faces.findAt(((
			0.025 + current_horizontal_wc, current_long_axis_2, 0.019 - current_depth_2),)), point1=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].InterestingPoint(
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt((
			0.025 + current_horizontal_wc + current_long_axis_2 * math.cos(current_angle_2), 0.0,
			0.019 - current_depth_2 + current_long_axis_2 * math.sin(current_angle_2)), ),
			MIDDLE), point2=mdb.models['Model-1'].rootAssembly.instances['pipe-1'].InterestingPoint(
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt((
			0.025 + current_horizontal_wc - current_long_axis_2 * math.cos(current_angle_2), 0.0,
			0.019 - current_depth_2 - current_long_axis_2 * math.sin(current_angle_2)), ), MIDDLE))

		# Seed the crack perimeter
		mdb.models['Model-1'].rootAssembly.seedEdgeBySize(constraint=FINER, deviationFactor=0.8, edges=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(
			((0.025 + current_horizontal_wc, current_long_axis_2, 0.019 - current_depth_2),)),
			minSizeFactor=0.8, size=mesh_size_general)

		# Set Tet element type for the crack region
		mdb.models['Model-1'].rootAssembly.setMeshControls(elemShape=TET, regions=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(((0.025,
			0.001, corr_top.pointOn[2] - 0.0001),),((0.025 + current_horizontal_wc,
			0.001, crack_top_2.pointOn[2] - 0.0001),)), sizeGrowthRate=1.2,technique=FREE)

		mdb.models['Model-1'].rootAssembly.setElementType(elemTypes=(ElemType(
			elemCode=UNKNOWN_HEX, elemLibrary=EXPLICIT), ElemType(
			elemCode=UNKNOWN_WEDGE, elemLibrary=EXPLICIT), ElemType(elemCode=C3D10M,
			elemLibrary=EXPLICIT, secondOrderAccuracy=OFF,distortionControl=DEFAULT)),
			regions=(mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(
			((0.025, 0.001, corr_top.pointOn[2] - 0.0001),),((0.025 + current_horizontal_wc,
			0.001, crack_top_2.pointOn[2] - 0.0001),)),))

		# Set the probe region to medial axis meshing
		mdb.models['Model-1'].rootAssembly.setMeshControls(algorithm=MEDIAL_AXIS,
			regions=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(((
			0.025, 0.001, 0.0189), )), sizeGrowthRate=1.2)

		## Mesh regions
		# Mesh the center region
		mdb.models['Model-1'].rootAssembly.generateMesh(regions=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(
			((0.025, 0.001, 0.0189),)))

		# Mesh the connection region
		mdb.models['Model-1'].rootAssembly.generateMesh(regions=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(
			((0.0111, 0.0001, 0.0189),), ((0.0281, 0.0001, 0.0189),)))

		# Mesh the connection region near the crack region
		mdb.models['Model-1'].rootAssembly.generateMesh(regions=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(
			((0.0111, 0.0001, crack_top_2.pointOn[2] - 0.0001),)))

		# Mesh the crack region
		mdb.models['Model-1'].rootAssembly.generateMesh(regions=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(
			((0.025, 0.0001, crack_top_2.pointOn[2] - 0.0001),)))

		# Mesh the corrosion region
		mdb.models['Model-1'].rootAssembly.generateMesh(regions=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(
			((0.025, 0.001, corr_top.pointOn[2] - 0.0001),)))

		# Mesh the out region
		mdb.models['Model-1'].rootAssembly.generateMesh(regions=
			mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(
			((0.001, 0.001, 0.018),), ((0.001, 0.001, 0.001),)))

	"""Create steps"""
	mdb.models['Model-1'].ExplicitDynamicsStep(name='Step-1', previous='Initial', 
		timeIncrementationMethod=FIXED_USER_DEFINED_INC, timePeriod=total_time,
		userDefinedInc=time_increment)
	mdb.models['Model-1'].fieldOutputRequests['F-Output-1'].suppress()
	mdb.models['Model-1'].historyOutputRequests['H-Output-1'].suppress()
	mdb.models['Model-1'].HistoryOutputRequest(createStepName='Step-1', frequency=1
		, name='H-Output-2', rebar=EXCLUDE, region=
		mdb.models['Model-1'].rootAssembly.sets['Sensor'], sectionPoints=DEFAULT,
		variables=('U3',))
	# 2.5 cycles
	mdb.models['Model-1'].TabularAmplitude(data=((0.0, 0.0), (5e-09,
    0.00194897732422402), (1e-08, 0.00749936469779943), (1.5e-08,
    0.0157821751620511), (2e-08, 0.0254167565564769), (2.5e-08,
    0.0346082692225902), (3e-08, 0.0412763459590382), (3.5e-08,
    0.0432076140126375), (4e-08, 0.038223337957104), (4.5e-08,
    0.0243524776957952), (5e-08, 1.16943363265131e-17), (5.5e-08,
    -0.0358996381001867), (6e-08, -0.0837533001355521), (6.5e-08,
    -0.143212617023721), (7e-08, -0.213116831660765), (7.5e-08,
    -0.291479843409094), (8e-08, -0.375524011195478), (8.5e-08,
    -0.461760857512023), (9e-08, -0.546116346548657), (9.5e-08,
    -0.624096012021681), (1e-07, -0.690983005625053), (1.05e-07,
    -0.74206023861849), (1.1e-07, -0.772846296026448), (1.15e-07,
    -0.779333795384948), (1.2e-07, -0.758218396990101), (1.25e-07,
    -0.707106781186548), (1.3e-07, -0.624692593655586), (1.35e-07,
    -0.510890597079379), (1.4e-07, -0.366921005010254), (1.45e-07,
    -0.195338134499781), (1.5e-07, -2.40462520828615e-16), (1.55e-07,
    0.214021832507633), (1.6e-07, 0.44059003132148), (1.65e-07,
    0.672702090996347), (1.7e-07, 0.90273634016427), (1.75e-07,
    1.122733718964), (1.8e-07, 1.32470383470392), (1.85e-07, 1.5009424616851),
    (1.9e-07, 1.64434687957902), (1.95e-07, 1.74871528675894), (2e-07,
    1.80901699437495), (2.05e-07, 1.82162118825236), (2.1e-07,
    1.78447369462384), (2.15e-07, 1.69721333119772), (2.2e-07,
    1.56122197242876), (2.25e-07, 1.37960529315051), (2.3e-07,
    1.15710415002271), (2.35e-07, 0.89993957958565), (2.4e-07,
    0.615597297450343), (2.45e-07, 0.31256024239776), (2.5e-07,
    6.12323399573677e-16), (2.55e-07, -0.312560242397761), (2.6e-07,
    -0.615597297450346), (2.65e-07, -0.899939579585651), (2.7e-07,
    -1.15710415002271), (2.75e-07, -1.3796052931505), (2.8e-07,
    -1.56122197242876), (2.85e-07, -1.69721333119772), (2.9e-07,
    -1.78447369462384), (2.95e-07, -1.82162118825236), (3e-07,
    -1.80901699437495), (3.05e-07, -1.74871528675894), (3.1e-07,
    -1.64434687957902), (3.15e-07, -1.5009424616851), (3.2e-07,
    -1.32470383470392), (3.25e-07, -1.122733718964), (3.3e-07,
    -0.902736340164271), (3.35e-07, -0.672702090996346), (3.4e-07,
    -0.440590031321481), (3.45e-07, -0.214021832507635), (3.5e-07,
    -5.61079215266769e-16), (3.55e-07, 0.195338134499779), (3.6e-07,
    0.366921005010254), (3.65e-07, 0.510890597079379), (3.7e-07,
    0.624692593655586), (3.75e-07, 0.707106781186547), (3.8e-07,
    0.758218396990101), (3.85e-07, 0.779333795384948), (3.9e-07,
    0.772846296026448), (3.95e-07, 0.74206023861849), (4e-07,
    0.690983005625053), (4.05e-07, 0.624096012021681), (4.1e-07,
    0.546116346548657), (4.15e-07, 0.461760857512022), (4.2e-07,
    0.375524011195478), (4.25e-07, 0.291479843409095), (4.3e-07,
    0.213116831660765), (4.35e-07, 0.143212617023721), (4.4e-07,
    0.0837533001355522), (4.45e-07, 0.0358996381001871), (4.5e-07,
    1.05249026938618e-16), (4.55e-07, -0.0243524776957951), (4.6e-07,
    -0.0382233379571039), (4.65e-07, -0.0432076140126374), (4.7e-07,
    -0.0412763459590381), (4.75e-07, -0.0346082692225902), (4.8e-07,
    -0.0254167565564767), (4.85e-07, -0.015782175162051), (4.9e-07,
    -0.00749936469779942), (4.95e-07, -0.00194897732422402), (5e-07, 0.0)),
    name='cos_2_5', smooth=SOLVER_DEFAULT, timeSpan=STEP)
	mdb.models['Model-1'].Pressure(amplitude='cos_2_5', createStepName='Step-1',
		distributionType=UNIFORM, field='', magnitude=1000000.0, name='Load-1',
		region=mdb.models['Model-1'].rootAssembly.surfaces['Exciter'])
	mdb.models['Model-1'].YsymmBC(createStepName='Step-1', localCsys=None, name=
		'BC-1', region=mdb.models['Model-1'].rootAssembly.sets['sym_plane'])
	mdb.Job(activateLoadBalancing=False, atTime=None, contactPrint=OFF, 
		description='', echoPrint=OFF, explicitPrecision=DOUBLE, historyPrint=OFF, 
		memory=90, memoryUnits=PERCENTAGE, model='Model-1', modelPrint=OFF, 
		multiprocessingMode=DEFAULT, name='Combined_flaw_3D_'+str(current_index), nodalOutputPrecision=FULL,
		numCpus=10, numDomains=10, parallelizationMethodExplicit=DOMAIN, queue=None
		, resultsFormat=ODB, scratch='', type=ANALYSIS, userSubroutine='', 
		waitHours=0, waitMinutes=0)
	break
	mdb.jobs['Combined_flaw_3D_'+str(current_index)].submit(consistencyChecking=OFF)
	mdb.jobs['Combined_flaw_3D_'+str(current_index)].waitForCompletion()

	# Open ODB file after the job is finished
	Odb_path = 'Combined_flaw_3D_'+str(current_index)+'.odb'
	odb = openOdb(Odb_path)

	# Open history steps data
	try:
		step1 = odb.steps['Step-1']
	except KeyError:
		failed_mesh.append(current_index)
		odb.close()
		pass
	else:
		# Use a loop to get the U3 data of all the nodes
		set_sensor = odb.rootAssembly.nodeSets['SENSOR'].nodes[0]

		try:
			region = step1.historyRegions['Node PIPE-1.'+str(set_sensor[0].label)]
		except KeyError:
			failed_mesh.append(current_index)
			odb.close()
			pass
		else:
			time, U3_total = zip(*step1.historyRegions['Node PIPE-1.' + str(set_sensor[0].label)].historyOutputs['U3'].data)
			for i in range(1,len(set_sensor)):
				time, U3 = zip(*step1.historyRegions['Node PIPE-1.' + str(set_sensor[i].label)].historyOutputs['U3'].data)
				U3_total = [a + b for a, b in zip(U3_total, U3)]

			U3_ave = [a / len(set_sensor) for a in U3_total]

			nn = len(U3_ave)
			if nn < sampling_number:
				odb.close()
				failed_earlystop.append(current_index)
			else:
				for i in range(nn):
					sheet1.write_number(current_index - 1, i, U3_ave[i])

				sheet2.write_number(0, current_index - 1, flaw_type)
				sheet2.write_number(1, current_index - 1, current_long_axis_1 * (long_axis_1 == True))
				sheet2.write_number(2, current_index - 1, current_depth_1 * (depth_1 == True))
				sheet2.write_number(3, current_index - 1, current_angle_1 / math.pi * 180.0 * (angle_1 == True))
				sheet2.write_number(4, current_index - 1, current_loss_height * (loss_height == True))
				sheet2.write_number(5, current_index - 1, current_loss_width * (loss_width == True))
				sheet2.write_number(6, current_index - 1, current_long_axis_2 * (long_axis_2 == True))
				sheet2.write_number(7, current_index - 1, current_depth_2 * (depth_2 == True))
				sheet2.write_number(8, current_index - 1, current_angle_2 / math.pi * 180.0 * (angle_2 == True))
				sheet2.write_number(9, current_index - 1, current_horizontal_cc * (horizontal_cc == True))
				sheet2.write_number(10, current_index - 1, current_horizontal_wc * (horizontal_wc == True))
				odb.close()

	# Remove all the files after getting the data
	try:
		os.remove('Combined_flaw_3D_' + str(current_index) + '.abq')
	except WindowsError:
		pass
	try:
		os.remove('Combined_flaw_3D_' + str(current_index) + '.mdl')
	except WindowsError:
		pass
	try:
		os.remove('Combined_flaw_3D_' + str(current_index) + '.pac')
	except WindowsError:
		pass
	try:
		os.remove('Combined_flaw_3D_' + str(current_index) + '.stt')
	except WindowsError:
		pass
	try:
		os.remove('Combined_flaw_3D_' + str(current_index) + '.inp')
	except WindowsError:
		pass
	try:
		os.remove('Combined_flaw_3D_' + str(current_index) + '.prt')
	except WindowsError:
		pass
	try:
		os.remove('Combined_flaw_3D_' + str(current_index) + '.res')
	except WindowsError:
		pass
	if remove_odb:
		try:
			os.remove('Combined_flaw_3D_' + str(current_index) + '.odb')
		except WindowsError:
			pass

	current_index = current_index + 1

"""Close the workbooks"""
wb1.close()
wb2.close()

# Write error message
len_fail_mesh = len(failed_mesh)
len_fail_earlystop = len(failed_earlystop)
with open('combined_flaw_3D/Combined_flaw_3D_failed_simulation.txt', 'w') as f:
	for i in range(0, len_fail_mesh):
		f.write('%s, ' % failed_mesh[i])
	f.write('\nOut of '+str(num_of_simulation)+' simulations, '+str(len_fail_mesh)+' have failed due to mesh generation.')
	f.write('\n')
	for i in range(0, len_fail_earlystop):
		f.write('%s, ' % failed_earlystop[i])
	f.write('\nOut of '+str(num_of_simulation)+' simulations, '+str(len_fail_earlystop)+' have failed due to unexpected stop.')
